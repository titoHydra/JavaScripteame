/* 
	SETUPS SOME TYPES OF LISTENERS/OBSERVERS AND NOTIFIES TO THE REGISTERED EXTENSIONS OF THESE EVENTS WHEN NEEDED
	__EXT_AUTOR__ <__EXT_AUTOR_EMAIL__>
	Notifies about:
		"onExtensionUninstall" 
								this event fire when the user disable or uninstall the extension and the browser will be closed/restarted. 
								this one is good to ask something like:
									"This extension (extension name) was disabled or uninstalled want remove user data generated by this extension?"
		"onApplicationQuit"
								this event fire when the whole application will be closed or restarted.
		"onIdle"
								this event fire when the user was idle for about 35 minutes
								this one is good for vacuum databases
		"onConnectionOffline"
								this event fire when the connection goes offline
		"onConnectionOnline"
								this event fire when the connection goes online
		"onPrivateBrowsingEnter"
								this event fire when the user enter in private browsing
								this one is good for extensions that collect data from webpages or sent data to some server to retrieive information
		"onPrivateBrowsingExit"
								this event fire when the user exit of private browsing

	QQQ - The event onExtensionUninstall and onApplicationQuit is not dispatched when the last window/dialog openend is not
	overlay by this extension. :( .... sometimes I feel that I need to write extensions complety inside an XPCOM...
*/

/*https://developer.mozilla.org/en/How_to_Build_an_XPCOM_Component_in_Javascript*/
/***********************************************************
constants
***********************************************************/

// reference to the interface defined in nsITheListeners.idl
const nsITheListeners = Components.interfaces.nsITheListeners;

// reference to the required base interface that all components must support
const nsISupports = Components.interfaces.nsISupports;

// UUID uniquely identifying our component
// You can get from: http://kruithof.xs4all.nl/uuid/uuidgen
const CLASS_ID = Components.ID("{cd93f790-d3a3-11de-8a39-0800200c9a66}");

// description
const CLASS_NAME = "Setups some types of listeners/observers and notifies to the registered extensions of these events when needed";

// textual unique identifier
const CONTRACT_ID = "@particle.universe.tito/TheListeners;1";

/***********************************************************
class definition
***********************************************************/

//class constructor
function TheListeners()
{
	// If you only need to access your component from Javascript, uncomment the following line:
	this.wrappedJSObject = this;
	this.init();
}

// class definition
TheListeners.prototype = 
{
	debugingThisFile : false,
	consoleService : Components.classes["@mozilla.org/consoleservice;1"].
						getService(Components.interfaces.nsIConsoleService),
	
	listeneresAdded : false,
	extensions : [],
	extensionsToUninstallOrDisabled : [],

	observe: function(aSubject, aTopic, aData)
	{
			//listening em-action-requested
			if(aTopic == 'em-action-requested')
			{
				//just save the state of the add-on
				/*
					item-installed 	A new extension has been installed.
					item-upgraded 	A different version of an existing extension has been installed.
					item-uninstalled 	An addon has been marked to be uninstalled.
					item-enabled 	An addon has been enabled.
					item-disabled 	An addon has been disabled.
					item-cancel-action 	A previous action has been cancelled.
				*/
				aSubject.QueryInterface(Components.interfaces.nsIUpdateItem);
					
				if(aData == 'item-installed'){}
				else if(aData == "item-upgraded"){}
				else if(aData == "item-uninstalled")
				{
					this.extensionsToUninstallOrDisabled[aSubject.id] = true;
				}
				else if(aData == "item-enabled")
				{
					delete this.extensionsToUninstallOrDisabled[aSubject.id];
				}
				else if(aData == "item-disabled")
				{
					this.extensionsToUninstallOrDisabled[aSubject.id] = true;
				}
				else if(aData == "item-cancel-action")
				{
					delete this.extensionsToUninstallOrDisabled[aSubject.id];
				}
			}
			else
			{
				//some event maybe will be dispatched
					var anEvent = false;
					
					//quit application
					if(aTopic == 'quit-application-requested')
					{
						anEvent = 'onApplicationQuit';
						aSubject.QueryInterface(Components.interfaces.nsISupportsPRBool);
					}
					//idle
					else if(aTopic == 'idle')
					{
						anEvent = 'onIdle';
					}
					//network online/offline
					else if(aTopic == 'network:offline-status-changed')
					{
						if(aData == 'offline')
							anEvent = 'onConnectionOffline';
						else if(aData == 'online')
							anEvent = 'onConnectionOnline';
					}
					//private browsing
					else if(aTopic == 'private-browsing')
					{
						if(aData == 'enter')
							anEvent = 'onPrivateBrowsingEnter';
						else if(aData == 'exit')
							anEvent = 'onPrivateBrowsingExit';
					}

				//dispatch the event to the registered extensions on the focused window
					if(!anEvent){}
					else
					{						
						//if there is some extension registered
						if(this.extensions)
						{
							//gets the most recent window
							var wm = Components.classes["@mozilla.org/appshell/window-mediator;1"]  
										.getService(Components.interfaces.nsIWindowMediator);  
							var win = wm.getMostRecentWindow('navigator:browser');
							//for each registered extension..
							for(var extension in this.extensions)
							{								
								//this.dump('Calling to '+extension+'.dispatchEvent(\''+anEvent+'\', aSubject);');
								try{win[extension].dispatchEvent(anEvent, aSubject);}catch(e){}
								
								//calling to onExtensionUninstall if needed
								if(anEvent == 'onApplicationQuit' && this.extensionsToUninstallOrDisabled[this.extensions[extension]])
								{
									//this.dump('Calling to '+extension+'.dispatchEvent(\'onExtensionUninstall\', aSubject);');
									try{win[extension].dispatchEvent('onExtensionUninstall', aSubject);}catch(e){}
								}
							}
						}
					}
			}

	},
	init : function()
	{
		if(!this.listeneresAdded)
		{
			this.listeneresAdded = true;
			
				var observerService = Components.classes["@mozilla.org/observer-service;1"]
										.getService(Components.interfaces.nsIObserverService);
				
		/* useful for ask to clean user data on uninstalled or disabled extension*/
			//quit-application-requested
					observerService.addObserver(this, 'quit-application-requested', false);
			//em-action-requested
					observerService.addObserver(this, "em-action-requested", false);
					
		/* useful for vacuum databases */
			//idle
					var idleService = Components.classes["@mozilla.org/widget/idleservice;1"]
												.getService(Components.interfaces.nsIIdleService)
									idleService.addIdleObserver(this, 60*35);//60 seconds * 35 = 35 minutes
					
		/* useful for extension that depends of online data */
			//network:offline-status-changed
					observerService.addObserver(this, "network:offline-status-changed", false); 
					
		/* useful for extensions that collects things from webpages or send requests to servers */
			//private-browsing
					observerService.addObserver(this, "private-browsing", false); 
		}
	},
	registerExtension : function(anExtension, anIDExtension)
	{
		this.extensions[anExtension] = anIDExtension;
	},
	//output to the console messages
	dump : function(something)
	{
		if(this.debugingThisFile)
		{
			if(typeof(something) == 'string' || typeof(something) == 'number')
				this.consoleService.logStringMessage('XPCOM:TheListeners:'+something);
			else if(typeof(something) == 'undefined' )
				this.consoleService.logStringMessage('XPCOM:TheListeners:undefined');
			else if(something == null)
				this.consoleService.logStringMessage('XPCOM:TheListeners:null');
			else
				this.consoleService.logStringMessage('XPCOM:TheListeners:'+something.toSource());
		}
	},

  QueryInterface: function(aIID)
  {
    if (!aIID.equals(nsITheListeners) &&    
        !aIID.equals(nsISupports))
      throw Components.results.NS_ERROR_NO_INTERFACE;
    return this;
  }
};

/***********************************************************
class factory

This object is a member of the global-scope Components.classes.
It is keyed off of the contract ID. Eg:

myTheListeners = Components.classes["@dietrich.ganx4.com/TheListeners;1"].
                          createInstance(Components.interfaces.nsITheListeners);

***********************************************************/
var TheListenersFactory = {
  createInstance: function (aOuter, aIID)
  {
    if (aOuter != null)
      throw Components.results.NS_ERROR_NO_AGGREGATION;
    return (new TheListeners()).QueryInterface(aIID);
  }
};

/***********************************************************
module definition (xpcom registration)
***********************************************************/
var TheListenersModule = {
  registerSelf: function(aCompMgr, aFileSpec, aLocation, aType)
  {
    aCompMgr = aCompMgr.
        QueryInterface(Components.interfaces.nsIComponentRegistrar);
    aCompMgr.registerFactoryLocation(CLASS_ID, CLASS_NAME, 
        CONTRACT_ID, aFileSpec, aLocation, aType);
  },

  unregisterSelf: function(aCompMgr, aLocation, aType)
  {
    aCompMgr = aCompMgr.
        QueryInterface(Components.interfaces.nsIComponentRegistrar);
    aCompMgr.unregisterFactoryLocation(CLASS_ID, aLocation);        
  },
  
  getClassObject: function(aCompMgr, aCID, aIID)
  {
    if (!aIID.equals(Components.interfaces.nsIFactory))
      throw Components.results.NS_ERROR_NOT_IMPLEMENTED;

    if (aCID.equals(CLASS_ID))
      return TheListenersFactory;

    throw Components.results.NS_ERROR_NO_INTERFACE;
  },

  canUnload: function(aCompMgr) { return true; }
};

/***********************************************************
module initialization

When the application registers the component, this function
is called.
***********************************************************/
function NSGetModule(aCompMgr, aFileSpec) { return TheListenersModule; }